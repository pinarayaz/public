# Code Design & Form

In this exercise set you will practice several aspects related to both the design and the form of the code that you write. We touch upon inheritance and containment questions, code contracts, as well as how to write and comment code.



## Interface Contracts

Interface contracts allow developers to express precisely their expectations of the users of their interface and the guarantees their interface provides.

The interface designer typically constructs contracts out of three kinds of elements:

1. A method _pre-condition_, i.e., a condition that must hold whenever someone calls a method.
   The condition may refer to the method arguments or the public fields and methods of the class.
   It is a responsibility of the caller to make sure the condition holds.
2. A method _post-condition_, i.e., a condition that is guaranteed to hold right after the method returns.
   The condition may refer to the method arguments, public fields and methods of the class (their value prior and after the call), and the method return value.
3. A class _invariant_, i.e., a condition that holds between method calls.
   You can think of the class invariant as a mandatory part of every pre- and post-condition of every method.
   It is the implementation of the class that makes sure the invariant holds, by assuming it at the start of every method and ensuring at the end of every method.
   
(Note that the function signature is itself a kind of a contract: 
It requires the arguments to be of specific types, and it guarantees a particular type for the return value.
Depending on the type system of your programming language, this contract can be quite powerful.)

### Cofoja

The [Cofoja](https://github.com/nhatminhle/cofoja) framework allows a developer to add contracts to their methods.
These contracts are formulated as normal Java expressions in double quotes (`“like this”`).
Inside the contracts you can reference the method arguments and class members.

Here is an example for specifying the class invariant `s != null` for a class `CharacterSet`:

```java
@Invariant("s != null")
public class CharacterSet {
    public CharacterSet() {
        s = new StringBuffer();
    }
...
```

#### Exercise 1: Fibonacci and pre-conditions
In [`RecursiveFibonacci.java`](interface-contracts/src/main/java/ch/epfl/sweng/contracts/RecursiveFibonacci.java) we provide an implementation of a recursive Fibonacci number generator.
Fibonacci numbers are generated by a function defined on non-negative numbers, hence the contract: `0 <= n` and `0 <= result`;

[`RecursiveFibonacciTest.java`](interface-contracts/src/test/java/ch/epfl/sweng/contracts/RecursiveFibonacciTest.java) contains two junit tests.
`fibOnNegativeFails` checks that Cofoja indeed protects the function from incorrect calls (i.e., which violate the pre-condition).
`fibOf4` tests the corectness of the Fibonacci sequence computation.

Run the tests as usual, with `./gradlew test`

But, wait a minute! The second test fails.  It turns out that the pre-condition is violated.
Check your `build/reports/tests/test/index.html` report file to see the stack trace that points to the line that violated the pre-condition.

Fix the code.

#### Exercise 2: Dynamic Vector

Let's get a bit more sophisticated now.

In [`SwengVector.java`](interface-contracts/src/main/java/ch/epfl/sweng/contracts/SwengVector.java) you can find an example of a Java `interface` augmented with a contract.

The `add` post-condition contains two assertions:

1. The newly added element stays in the vector
2. All the old elements remain in the vector (the Javadoc comment provides some more details on how we formulate this)

[`SwengArrayList`](interface-contracts/src/main/java/ch/epfl/sweng/contracts/SwengArrayList.java) implements the `SwengVector` interface, but contains two bugs. The interface post-condition can catch both bugs, but we need to run the code such that it exercises the buggy behavior, because Cofoja checks the contracts _dynamically_, i.e., during execution, as opposed to _statically_ during compilation.

So [`SwengVectorTests`](interface-contracts/src/test/java/ch/epfl/sweng/contracts/SwengArrayList.java) contains a test that fails because of the bugs.

Use the Gradle report to find the failing checks. Use Cofoja contracts to confirm your assumptions about the code.

*Hint:* you may want to add an `"old(toList()).stream().allMatch(this::contains)"` post-condition to the `expandArray` method.

#### Exercise 3: Fraction

The following class implements rational numbers. Unfortunately, the `toInt()` method sometimes throws an `ArithmeticException`.
Add an invariant and a constructor pre-condition to make sure `toInt()` never throws an exception.
To do that, replace `<write your code here...>` with valid expressions.

You can copy this snippet into a file `interface-contracts/src/main/java/ch/epfl/sweng/contracts/Fraction.java` and add some tests to [`interface-contracts/src/test/java/ch/epfl/sweng/contracts/FractionTests.java`](interface-contracts/src/test/java/ch/epfl/sweng/contracts/FractionTests.java) to compile and test it.

```java
@Invariant("<write your code here(a)>")
public class Fraction {
  private int n;
  private int d;

  @Requires("<write your code here(b)>")
  public Fraction(int n, int d) {
    this.n = n;
    this.d = d;
  }

  public int toInt() {
    return n/d;
  }
}

```


#### Exercise 4: Stack

The following implementation of a stack may sometimes throw `java.lang.ArrayIndexOutOfBoundsException` exceptions. To solve this exercise, please provide in the code below the class invariant, pre-conditions, and post-conditions for methods `pop` and `push` that prevent these exceptions from arising, and thus make the code correct. You should provide replacements for the 5 placeholders `“<write your code here(a/b/c/d/e)>”`. You are not permitted to reference private class members in the pre- and post-conditions.

You can copy this snippet into a file `interface-contracts/src/main/java/ch/epfl/sweng/contracts/SwengStack.java` and add some tests to [`interface-contracts/src/test/java/ch/epfl/sweng/contracts/SwengStackTests.java`](interface-contracts/src/test/java/ch/epfl/sweng/contracts/SwengStackTests.java) to compile and test it.

```java
@Invariant("<write your code here(a)>")
class SwengStack {
    private int capacity;
    private int numberOfElements;
    private int[] contents;

    public SwengStack(int capacity) {
        this.capacity = capacity;
        numberOfElements = 0;
        contents = new int[capacity];
    }

    public boolean isEmpty() {
        return numberOfElements == 0;
    }

    public boolean isFull() {
        return numberOfElements == capacity;
    }

    @Requires("<write your code here(b)>")
    @Ensures("<write your code here(c)>")
    public int pop() {
        numberOfElements -= 1;
        return contents[numberOfElements];
    }

    @Requires("<write your code here(d)>")
    @Ensures("<write your code here(e)>")
    public void push(int x) {
        contents[numberOfElements] = x;
        numberOfElements += 1;
    }
}

```

### Exercise 5 (advanced): [Covariance and contravariance](https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science))
Inheritance can be treated, from the contractual point of view, as the obligation of the subclass to respect the contracts of the superclass.
So a `SwEngStudent` is first of all a `Student`.
This means you can always treat a `SwEngStudent` as if it were a student, i.e., you can ask for their `gaspar`, or expect them to take an exam.

It gets trickier when you consider collections of objects.
In Java, `List<? extends Student>` expresses a lower bound on the type of the objects in the list (where we consider `Object` the lowest object).
Such a list contains objects that can be treated as `Student`s.
`List<? super Student>` expresses an upper bound on the type of the objects in the list.
In such a list you can find `Object`s or `Student`s — any of the superclasses of `Student` including itself, but never a subclass (e.g. no `SwEngStudent`).

The latter case may sound pointless, but consider these two lists:

```java
List<? extends Student> l1 = ...;
List<? super Student> l2 = ...;

```

Which of the uses of `l1` and `l2` are safe?

```java
Student s1 = l1.get(0); // Use case 1
Student s2 = l2.get(0); // Use case 2
l1.add(new Student()); // Use case 3
l2.add(new Student()); // Use case 4

```

## Code Comments
You are given what a group of students wrote for a project where they implemented a UDP client-server application. The [`Server`](code-comments/Server.java) has two methods, ```listenAndRespond()``` and ```computeRecaman(int n)```. The first waits for a packet containing an integer. It transmits this integer to the second method, which computes [Recaman's sequence](https://oeis.org/A005132) up to the `n`-th term and sends the result back to the client (as a `String`).
The [`Client`](code-comments/Client.java) has one main method: ```requestRecamanSequence(int n)``` that sends a request to the server to compute Recaman's sequence.
Unfortunately, even though the students produced that works, the group is terrible at commenting their code.

Your goal in the following four exercises is to help the students fix their comments.

#### Exercise 6

Let's begin fairly easy, one of the students wrote the comments for ```requestRecamanSequence(int n)```. What issue do you see with the comments? Remove, add, or modify the comments in order to have comments that match what you were taught in SwEng.

#### Exercise 7

Another student took care of ```listenAndRespond()```, and wrote a *warning* at the beginning of the method.
In that specific case, the students should handle the specified case in the method. But, more generally, is it reasonable to use comments for potential compatibility issues? Why? 

The student also wrote two comments that do not respect the SwEng "rules". Can you spot the problem and fix it?

#### Exercise 8

A third student programmed the ```computeRecaman(int n)``` method. Explain what issue is highlight by the comments and how to correct it.

#### Exercise 9

The fourth and last student took care of writing the JavaDoc, but forgot to write it for the [`Client`](code-comments/Client.java) class. Finish this exercise by following the convention given in lecture for writing good JavaDoc for this class.

What is important when writing a JavaDoc comment for a class? What about a method?

## Coding Style
In this exercise we will consider the [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html).
There are a number of other coding conventions for Java, e.g., published by [Oracle](http://www.oracle.com/technetwork/java/codeconventions-150003.pdf), the one used for [Spring](https://github.com/spring-projects/spring-framework/wiki/Code-Style), one published by the [Software Engineering Institute](https://wiki.sei.cmu.edu/confluence/display/java/Java+Coding+Guidelines), and so on.
For other languages you can find such conventions online.

#### Exercise 10
Reformat the following code snippet according to the Google Java Style Guide
(you are free to change identifiers and method signatures, do not worry if it breaks some hypothetical code that might depend on this class):

```Java
/**
    class Rocket
*/class
Rocket
extends projectile implements
Ex_plosive
{private final static float rocketradius = 3e0;private Integer power; private poInt Position; private poInt Velocity; public boolean InFlight;
public Rocket(int p, float y, float vX, float vY, player Owner, float x)
throws OutOfBoUnDsExCePtIoN {super   (x,y,Owner);
       this.Velocity = new poInt(vX,vY);
       this.Position=new poInt(x,y);this.power = p;
       InFlight=true;
} private void updateTheRocketPositionByIncrementingItByTheProvidedDisplacementVectorWithoutAnyBoundsChecksWhatSoEver(poInt DisplacementVectorProvided)
{this.Position.move(DisplacementVectorProvided);}
private void bouger(float dt) {
  updateTheRocketPositionByIncrementingItByTheProvidedDisplacementVectorWithoutAnyBoundsChecksWhatSoEver(Velocity.fois(dt));
}
public boolean CollisionYes(float horisontalLongitude, float VerticalAltitude, float theRadiusOfTheObject, float x) {
  if (this.InFlight == Circle.intersect(horisontalLongitude, VerticalAltitude, x + theRadiusOfTheObject, rocketradius, Position.horisontal, Posotion.vertical)) {
    if (this.InFlight) return true;
  else return false;
  } else if (this.InFlight) return false;
  else return false;
return true;
} 
public Boom explode() { return this.InFlight = false, new Boom(Position, power); }
}
```

## Inheritance/Containment


`ORDER X7F351.XIV: Engineering Requisition`

`The United League of Planets (ULP) has been at war with the Antarean Empire for years.`

`United League Space Navy (ULSN) High Command has determined that time and resources are being wasted, and battles lost, due to the outdated logistics and deployment tracking software system for both civilian and military assets of the fleet. Brittle and poorly designed software is also a vulnerable target for imperial spies. 
As such, High Command has tasked your engineering unit with the design of a new logistics system -- quality, extensibility, and maintainability are of the utmost importance. 
The admiralty expects your design to make effective use of inheritance, interfaces, and containment where appropriate, and to construct a mock-up using the ancient Earth programming language known as _Java_.`

`Exact specifications are listed below. This is a Class XIV assignment, failure to complete may result in court martial and summary sentencing.`

#### Specification

The primary requirement is to design data structures that can be used to represent ULSN vessels, their characteristics, and mission profiles.

All vessel classes in the ULSN share multiple core attributes, which must be present in any ship class. These include:

1. Exterior Coating
2. Fuel
3. Mass
4. Cargo
5. Crew complement (i.e., the size of the crew)

##### Cargo

All ULSN vessels can carry some amount of cargo. Cargo systems are modular, and capacity is represented by `Pods`. A ship, depending on its particular class, can carry a certain amount of cargo `Pod`s. Pods themselves carry a fixed amount of `CargoItem`s. 

All ships should be able to load and unload cargo.

##### Ship Types and Mission Profiles

ULSN classifies ships into two types: `Civilian` and `Military`. The main difference is that `Military` ships have `Weapon`s, and `Civilian` ships do not. 

Ships in general are capable of executing different `MissionProfile`s. These include:

1. `SearchAndDestroy` -- destroy enemy vessels in a particular sector
2. `Patrol` -- patrol a set of sectors
3. `Reconaissance` -- reconnoiter a particular sector
4. `Delivery` -- pick up goods in one sector, deliver to another sector
5. `Ferry` -- ferry passengers from one sector to another

Missions profiles should have appropriate ways of allowing High Command to issue orders.

`START CLASSIFIED SECTION`

>ULSN engineering divisions have recently perfected autonomous system upgrades to portions of the fleet. Some ships no longer require crew to function or complete missions. An autonomous ship must be able to `enterAutonomousMode`.

`END CLASSIFIED SECTION`

Ship types are further divided into classes.  `Military` ship classes, crew status, and associated `MissionProfile`s include:

1. `Battleship` -- Crewed -- `SearchAndDestroy`, `Patrol`
2. `Frigate` -- Crewed -- `SearchAndDestroy`, `Patrol`, `Reconaissance`
3. `Destroyer` -- Crewed -- `Patrol`, `Delivery`
4. `Corvette` -- Autonomous -- `Patrol`, `Reconaissance`, `Delivery`

Civilian ship classes, crew status, and mission profiles include:

1. `Transport` -- Crewed -- `Ferry`, `Delivery`
2. `Freighter` -- Autnomous -- `Delivery`
3. `ExecutiveShuttle` -- Autonomous -- `Ferry`

Civilian ships must also process cargo manifests whenever they unload cargo. 

##### Armaments and Ordnance

All `Military` ships contain weapons arrays, i.e., multiple weapons of varying types. ULSN `Weapon`s fall into several categories, with some requiring `Ammunition` and others not. They are listed as follows:

1. `PlasmaCannon`s -- do not require `Ammunition`
2. `Railgun`s -- require `Ammunition`
3. `Missile`s -- require `Ammunition`

All military ships must accomodate variable weapon loadouts with different numbers and types of weapons.
Weapons requiring ammunition must be able to `reload` and report their current ammunition level.
All military ships must be able to `fire` their weapons.

#### Orders

As stated, your orders are to design and implement data structures that can represent all ULSN ships, making effective use of inheritance, inferfaces, and containment. Do your part, help return technological dominance to the League, and ensure defeat of the Imperial scum.
